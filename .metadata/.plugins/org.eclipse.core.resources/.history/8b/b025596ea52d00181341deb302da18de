package ex2;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.Scanner;

public class Q5 {
	/*
	 * public static void main(String[] args) {
	 * 
	 * Scanner sc = new Scanner(System.in);
	 * 
	 * while (true) {
	 * System.out.println("---------------------------------------------------")
	 * ; System.out.
	 * println("Saisissez une adresse symbolique :  (\"stop\" pour arrêter)" );
	 * System.out.println("---------------------------------------------------")
	 * ; String hote = sc.nextLine(); if (hote.equalsIgnoreCase("stop")) {
	 * break; } System.out.println("Voici le résultat trouvé : ");
	 * System.out.println(adressToIP(hote)); }
	 * 
	 * System.out.println("Bye !!"); }
	 * 
	 * public static String adressToIP(String host) { String result = "";
	 * 
	 * try { result = InetAddress.getByName(host).getHostAddress(); } catch
	 * (UnknownHostException e) { return
	 * "Erreur : impossible de trouver une correspondance pour l'entrée " +
	 * host; } return result; }
	 */

	public static void main(String[] args) throws IOException {

		Scanner sc = new Scanner(System.in);

		while (true) {
			System.out.println("\n-----------------------------------------------------------");
			System.out.println("Saisissez une adresse symbolique : (\"stop\" pour terminer) ");
			System.out.println("-----------------------------------------------------------");
			String domain = sc.nextLine();
			if (domain.equalsIgnoreCase("stop")) {
				System.out.println("bye");
				break;
			}
			printDatagram(domain);
		}
		sc.close();

	}

	private static void printDatagram(String domain)
			throws IOException {


		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		DataOutputStream dos = new DataOutputStream(baos);

		// *** Build a DNS Request Frame ****

		// Identifier: A 16-bit identification field generated by the device
		// that creates the DNS query.
		// It is copied by the server into the response, so it can be used by
		// that device to match that
		// query to the corresponding reply received from a DNS server. This is
		// used in a manner similar
		// to how the Identifier field is used in many of the ICMP message
		// types.
		dos.writeShort(0x1234);

		// Write Query Flags
		dos.writeShort(0x0100);

		// Question Count: Specifies the number of questions in the Question
		// section of the message.
		dos.writeShort(0x0001);

		// Answer Record Count: Specifies the number of resource records in the
		// Answer section of the message.
		dos.writeShort(0x0000);

		// Authority Record Count: Specifies the number of resource records in
		// the Authority section of
		// the message. (“NS” stands for “name server”)
		dos.writeShort(0x0000);

		// Additional Record Count: Specifies the number of resource records in
		// the Additional section of the message.
		dos.writeShort(0x0000);

		String[] domainParts = domain.split("\\.");
		System.out.println(domain + " has " + domainParts.length + " parts");

		for (int i = 0; i < domainParts.length; i++) {
			System.out.println("Writing: " + domainParts[i]);
			byte[] domainBytes = domainParts[i].getBytes("UTF-8");
			dos.writeByte(domainBytes.length);
			dos.write(domainBytes);
		}

		// No more parts
		dos.writeByte(0x00);

		// Type 0x01 = A (Host Request)
		dos.writeShort(0x0001);

		// Class 0x01 = IN
		dos.writeShort(0x0001);

		byte[] dnsFrame = baos.toByteArray();

		System.out.println("Sending: " + dnsFrame.length + " bytes");
		for (int i = 0; i < dnsFrame.length; i++) {
			System.out.print("0x" + String.format("%x", dnsFrame[i]) + " ");
		}

	}

}
